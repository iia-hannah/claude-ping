{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Structure and Dependencies",
        "description": "Initialize the Node.js project structure with necessary dependencies for the Claude-Ping CLI tool",
        "details": "1. Create a new Node.js project with `npm init`\n2. Install required dependencies:\n   - commander (for CLI interface)\n   - node-cron (for scheduling)\n   - chalk (for colored output)\n   - inquirer (for interactive prompts)\n   - child_process (for executing Claude CLI)\n   - fs-extra (for file operations)\n3. Setup project directory structure:\n   ```\n   claude-ping/\n   ├── bin/\n   │   └── claude-ping.js (executable)\n   ├── lib/\n   │   ├── commands/\n   │   │   ├── start.js\n   │   │   ├── stop.js\n   │   │   ├── status.js\n   │   │   ├── test.js\n   │   │   └── config.js\n   │   ├── services/\n   │   │   ├── claude-service.js\n   │   │   ├── process-manager.js\n   │   │   └── auto-start-service.js\n   │   └── utils/\n   │       ├── logger.js\n   │       └── config-manager.js\n   ├── package.json\n   └── README.md\n   ```\n4. Configure package.json for global installation\n5. Create default configuration template",
        "testStrategy": "1. Verify project structure is correctly set up\n2. Ensure all dependencies are properly installed\n3. Validate package.json configuration for global installation\n4. Test basic project loading without errors",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Core CLI Command Interface",
        "description": "Create the main CLI command interface with all required commands and options as specified in the PRD",
        "details": "1. Create the main executable script in bin/claude-ping.js\n2. Use Commander.js to implement the command structure:\n   ```javascript\n   #!/usr/bin/env node\n   const { program } = require('commander');\n   const pkg = require('../package.json');\n   \n   program\n     .version(pkg.version)\n     .description('Claude Code CLI token optimization automation tool');\n   \n   program\n     .command('start')\n     .description('Start the background process')\n     .option('-i, --interval <hours>', 'Set ping interval in hours (1-24)', '5')\n     .option('-f, --foreground', 'Run in foreground mode')\n     .option('--retry-count <count>', 'Number of consecutive retries (1-10)', '3')\n     .option('--retry-interval <minutes>', 'Minutes between retries (1-10)', '2')\n     .option('--no-retry', 'Disable retry mechanism')\n     .action(require('../lib/commands/start'));\n   \n   program\n     .command('status')\n     .description('Check current running status')\n     .action(require('../lib/commands/status'));\n   \n   program\n     .command('test')\n     .description('Test Claude connection')\n     .action(require('../lib/commands/test'));\n   \n   program\n     .command('config')\n     .description('Show configuration file')\n     .action(require('../lib/commands/config'));\n   \n   program\n     .command('stop')\n     .description('Stop running process')\n     .action(require('../lib/commands/stop'));\n   \n   program.parse(process.argv);\n   ```\n3. Create placeholder command files in lib/commands/\n4. Implement help text and command validation\n5. Add option validation for interval ranges (1-24 hours), retry count (1-10), and retry interval (1-10 minutes)",
        "testStrategy": "1. Test each command with --help flag to verify help text\n2. Verify all commands are properly registered\n3. Test option parsing with various inputs\n4. Validate error handling for invalid options\n5. Ensure command routing works correctly",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Configuration Management",
        "description": "Create configuration management system to handle user settings and defaults",
        "details": "1. Create lib/utils/config-manager.js to handle configuration:\n   ```javascript\n   const fs = require('fs-extra');\n   const path = require('path');\n   const os = require('os');\n   \n   const CONFIG_DIR = path.join(os.homedir(), '.claude-ping');\n   const CONFIG_FILE = path.join(CONFIG_DIR, 'config.json');\n   \n   const DEFAULT_CONFIG = {\n     intervalHours: 5,\n     timeout: 30000,\n     retryCount: 3,\n     retryInterval: 2,\n     question: 'What time is it now?',\n     logLevel: 'info',\n     autoRestart: true\n   };\n   \n   function ensureConfigExists() {\n     fs.ensureDirSync(CONFIG_DIR);\n     if (!fs.existsSync(CONFIG_FILE)) {\n       fs.writeJsonSync(CONFIG_FILE, DEFAULT_CONFIG, { spaces: 2 });\n     }\n   }\n   \n   function getConfig() {\n     ensureConfigExists();\n     const config = fs.readJsonSync(CONFIG_FILE);\n     return { ...DEFAULT_CONFIG, ...config };\n   }\n   \n   function updateConfig(updates) {\n     const config = getConfig();\n     const newConfig = { ...config, ...updates };\n     fs.writeJsonSync(CONFIG_FILE, newConfig, { spaces: 2 });\n     return newConfig;\n   }\n   \n   module.exports = {\n     CONFIG_DIR,\n     CONFIG_FILE,\n     DEFAULT_CONFIG,\n     getConfig,\n     updateConfig,\n     ensureConfigExists\n   };\n   ```\n2. Create directory structure for logs and PID file\n3. Implement the config command to display current configuration\n4. Add validation for configuration values\n5. Ensure configuration is properly loaded at startup",
        "testStrategy": "1. Test creation of default configuration file\n2. Verify config directory structure is created correctly\n3. Test loading and saving configuration\n4. Validate merging of default and user configurations\n5. Test the config command output",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Claude CLI Integration",
        "description": "Create service to interact with Claude CLI for automated token reset",
        "details": "1. Create lib/services/claude-service.js:\n   ```javascript\n   const { spawn } = require('child_process');\n   const { getConfig } = require('../utils/config-manager');\n   const logger = require('../utils/logger');\n   \n   async function checkClaudeInstallation() {\n     return new Promise((resolve) => {\n       const process = spawn('claude', ['--version']);\n       process.on('error', () => resolve(false));\n       process.on('close', (code) => resolve(code === 0));\n     });\n   }\n   \n   async function pingClaude() {\n     const config = getConfig();\n     const question = config.question;\n     \n     return new Promise((resolve, reject) => {\n       logger.info('Starting Claude session...');\n       \n       const claudeProcess = spawn('claude', [], { stdio: ['pipe', 'pipe', 'pipe'] });\n       let responseReceived = false;\n       let timeout;\n       \n       // Set timeout\n       timeout = setTimeout(() => {\n         if (!responseReceived) {\n           claudeProcess.kill();\n           reject(new Error('Claude response timeout'));\n         }\n       }, config.timeout);\n       \n       claudeProcess.stdout.on('data', (data) => {\n         const output = data.toString();\n         if (output.includes('Human:')) {\n           logger.info(`Human: ${question}`);\n           claudeProcess.stdin.write(`${question}\\n`);\n         } else if (output.includes('Claude:')) {\n           logger.info(`Claude: ${output.split('Claude:')[1].trim()}`);\n           responseReceived = true;\n           claudeProcess.stdin.write('exit\\n');\n           clearTimeout(timeout);\n           resolve(true);\n         }\n       });\n       \n       claudeProcess.on('error', (error) => {\n         clearTimeout(timeout);\n         reject(error);\n       });\n       \n       claudeProcess.on('close', (code) => {\n         clearTimeout(timeout);\n         if (!responseReceived) {\n           reject(new Error(`Claude process exited with code ${code}`));\n         }\n       });\n     });\n   }\n   \n   module.exports = {\n     checkClaudeInstallation,\n     pingClaude\n   };\n   ```\n2. Implement error handling for Claude CLI not installed\n3. Add retry mechanism with exponential backoff for network errors\n4. Implement proper timeout handling\n5. Create test command to verify Claude connectivity",
        "testStrategy": "1. Test Claude installation check\n2. Verify successful interaction with Claude CLI\n3. Test error handling when Claude is not installed\n4. Test timeout handling\n5. Verify retry mechanism works correctly\n6. Test the test command functionality",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Process Management",
        "description": "Create background process management with PID tracking and signal handling",
        "details": "1. Create lib/services/process-manager.js:\n   ```javascript\n   const fs = require('fs-extra');\n   const path = require('path');\n   const { CONFIG_DIR } = require('../utils/config-manager');\n   const logger = require('../utils/logger');\n   \n   const PID_FILE = path.join(CONFIG_DIR, 'claude-ping.pid');\n   \n   function savePid(pid) {\n     fs.writeFileSync(PID_FILE, pid.toString());\n     logger.info(`PID saved: ${pid}`);\n   }\n   \n   function getPid() {\n     try {\n       if (fs.existsSync(PID_FILE)) {\n         return parseInt(fs.readFileSync(PID_FILE, 'utf8'));\n       }\n     } catch (error) {\n       logger.error('Error reading PID file:', error);\n     }\n     return null;\n   }\n   \n   function removePid() {\n     try {\n       if (fs.existsSync(PID_FILE)) {\n         fs.unlinkSync(PID_FILE);\n         logger.info('PID file removed');\n       }\n     } catch (error) {\n       logger.error('Error removing PID file:', error);\n     }\n   }\n   \n   function isRunning(pid) {\n     try {\n       if (pid && process.kill(pid, 0)) {\n         return true;\n       }\n     } catch (error) {\n       if (error.code !== 'ESRCH') {\n         logger.error('Error checking process status:', error);\n       }\n     }\n     return false;\n   }\n   \n   function setupSignalHandlers() {\n     ['SIGINT', 'SIGTERM', 'SIGHUP'].forEach(signal => {\n       process.on(signal, () => {\n         logger.info(`Received ${signal}, shutting down...`);\n         removePid();\n         process.exit(0);\n       });\n     });\n   }\n   \n   module.exports = {\n     savePid,\n     getPid,\n     removePid,\n     isRunning,\n     setupSignalHandlers,\n     PID_FILE\n   };\n   ```\n2. Implement status command to check if process is running\n3. Implement stop command to terminate running process\n4. Add proper signal handling for clean shutdown\n5. Create logging for process events",
        "testStrategy": "1. Test PID file creation and reading\n2. Verify process status checking\n3. Test signal handling for clean shutdown\n4. Verify stop command correctly terminates process\n5. Test status command output for running and stopped states",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Scheduling and Retry Logic",
        "description": "Create scheduling system with configurable intervals and retry mechanism",
        "details": "1. Create the start command implementation in lib/commands/start.js:\n   ```javascript\n   const { fork } = require('child_process');\n   const path = require('path');\n   const { getConfig, updateConfig } = require('../utils/config-manager');\n   const { savePid, getPid, isRunning } = require('../services/process-manager');\n   const { checkAutoStartService, setupAutoStart } = require('../services/auto-start-service');\n   const inquirer = require('inquirer');\n   const logger = require('../utils/logger');\n   \n   async function startDaemon(options) {\n     // Validate options\n     const interval = parseInt(options.interval);\n     if (isNaN(interval) || interval < 1 || interval > 24) {\n       throw new Error('Interval must be between 1 and 24 hours');\n     }\n     \n     const retryCount = options.retry ? parseInt(options.retryCount) : 0;\n     if (isNaN(retryCount) || retryCount < 0 || retryCount > 10) {\n       throw new Error('Retry count must be between 0 and 10');\n     }\n     \n     const retryInterval = parseInt(options.retryInterval);\n     if (isNaN(retryInterval) || retryInterval < 1 || retryInterval > 10) {\n       throw new Error('Retry interval must be between 1 and 10 minutes');\n     }\n     \n     // Update config with command options\n     updateConfig({\n       intervalHours: interval,\n       retryCount: options.retry ? retryCount : 0,\n       retryInterval: retryInterval\n     });\n     \n     // Check if already running\n     const pid = getPid();\n     if (pid && isRunning(pid)) {\n       logger.info(`Claude Ping is already running (PID: ${pid})`);\n       return;\n     }\n     \n     // Check auto-start service\n     const isAutoStartSetup = await checkAutoStartService();\n     if (!isAutoStartSetup) {\n       const { setupService } = await inquirer.prompt([\n         {\n           type: 'confirm',\n           name: 'setupService',\n           message: 'Setup auto-start on boot?',\n           default: true\n         }\n       ]);\n       \n       if (setupService) {\n         await setupAutoStart();\n         logger.info('✅ Auto-start service registered');\n       }\n     }\n     \n     // Start in foreground or background\n     if (options.foreground) {\n       logger.info(`🚀 Starting Claude Ping (${interval}h interval, ${options.retry ? retryCount : 0} retries)...`);\n       require('../services/scheduler').start();\n     } else {\n       // Fork a new process and detach\n       const child = fork(path.join(__dirname, '../services/scheduler.js'), [], {\n         detached: true,\n         stdio: 'ignore'\n       });\n       \n       // Save PID and detach\n       savePid(child.pid);\n       child.unref();\n       \n       logger.info(`🚀 Starting Claude Ping (${interval}h interval, ${options.retry ? retryCount : 0} retries)...`);\n       logger.info(`📄 PID saved: ${child.pid}`);\n       \n       // Calculate next ping time\n       const nextPing = new Date(Date.now() + interval * 60 * 60 * 1000);\n       logger.info(`⏰ Next ping scheduled: ${nextPing.toLocaleString()}`);\n       logger.info('\\nProcess running in background. Use \\'claude-ping status\\' to check.');\n     }\n   }\n   \n   module.exports = async function(options) {\n     try {\n       await startDaemon(options);\n     } catch (error) {\n       logger.error(`Failed to start: ${error.message}`);\n       process.exit(1);\n     }\n   };\n   ```\n\n2. Create the scheduler service in lib/services/scheduler.js:\n   ```javascript\n   const { getConfig } = require('../utils/config-manager');\n   const { pingClaude } = require('./claude-service');\n   const { savePid, setupSignalHandlers } = require('./process-manager');\n   const logger = require('../utils/logger');\n   \n   let mainTimer = null;\n   let retryTimer = null;\n   \n   async function executeRetrySequence() {\n     const config = getConfig();\n     const retryCount = config.retryCount;\n     const retryInterval = config.retryInterval * 60 * 1000; // convert to ms\n     \n     logger.info(`⏰ ${config.intervalHours}-hour timer triggered, starting retry sequence...`);\n     \n     // Execute first attempt immediately\n     let successCount = 0;\n     try {\n       logger.info(`🔄 Attempt 1/${retryCount}: Starting Claude session...`);\n       await pingClaude();\n       logger.info(`✅ Attempt 1 completed`);\n       successCount++;\n     } catch (error) {\n       logger.error(`❌ Attempt 1 failed: ${error.message}`);\n     }\n     \n     // Schedule remaining attempts\n     for (let i = 1; i < retryCount; i++) {\n       await new Promise(resolve => {\n         retryTimer = setTimeout(async () => {\n           try {\n             logger.info(`🔄 Attempt ${i+1}/${retryCount}: Starting Claude session...`);\n             await pingClaude();\n             logger.info(`✅ Attempt ${i+1} completed`);\n             successCount++;\n           } catch (error) {\n             logger.error(`❌ Attempt ${i+1} failed: ${error.message}`);\n           } finally {\n             resolve();\n           }\n         }, retryInterval);\n       });\n     }\n     \n     logger.info(`🎯 Retry sequence complete. ${successCount}/${retryCount} attempts succeeded.`);\n     logger.info(`Next cycle in ${config.intervalHours} hours...`);\n   }\n   \n   function start() {\n     // Save PID if not already saved\n     savePid(process.pid);\n     \n     // Setup signal handlers\n     setupSignalHandlers();\n     \n     // Get configuration\n     const config = getConfig();\n     const intervalMs = config.intervalHours * 60 * 60 * 1000; // convert to ms\n     \n     // Execute immediately on start\n     if (config.retryCount > 0) {\n       executeRetrySequence();\n     } else {\n       pingClaude().catch(error => {\n         logger.error(`Failed to ping Claude: ${error.message}`);\n       });\n     }\n     \n     // Setup main interval timer\n     mainTimer = setInterval(() => {\n       if (config.retryCount > 0) {\n         executeRetrySequence();\n       } else {\n         pingClaude().catch(error => {\n           logger.error(`Failed to ping Claude: ${error.message}`);\n         });\n       }\n     }, intervalMs);\n   }\n   \n   function stop() {\n     if (mainTimer) {\n       clearInterval(mainTimer);\n       mainTimer = null;\n     }\n     \n     if (retryTimer) {\n       clearTimeout(retryTimer);\n       retryTimer = null;\n     }\n   }\n   \n   // Start if this file is executed directly\n   if (require.main === module) {\n     start();\n   }\n   \n   module.exports = { start, stop };\n   ```\n3. Implement validation for interval and retry parameters\n4. Add logging for scheduling events\n5. Implement proper error handling for failed attempts",
        "testStrategy": "1. Test scheduling with different interval settings\n2. Verify retry mechanism works with configurable counts and intervals\n3. Test error handling during retry sequence\n4. Validate timer accuracy for long-running processes\n5. Test partial success scenarios in retry sequence",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Auto-Start Service Registration",
        "description": "Create platform-specific auto-start service registration for macOS, Linux, and Windows",
        "details": "1. Create lib/services/auto-start-service.js:\n   ```javascript\n   const fs = require('fs-extra');\n   const path = require('path');\n   const os = require('os');\n   const { exec } = require('child_process');\n   const { promisify } = require('util');\n   const execAsync = promisify(exec);\n   const logger = require('../utils/logger');\n   \n   const MACOS_PLIST_PATH = path.join(os.homedir(), 'Library/LaunchAgents/com.claude-ping.plist');\n   const LINUX_SERVICE_PATH = path.join(os.homedir(), '.config/systemd/user/claude-ping.service');\n   \n   async function checkAutoStartService() {\n     const platform = process.platform;\n     \n     try {\n       if (platform === 'darwin') { // macOS\n         return fs.existsSync(MACOS_PLIST_PATH);\n       } else if (platform === 'linux') { // Linux\n         return fs.existsSync(LINUX_SERVICE_PATH);\n       } else if (platform === 'win32') { // Windows\n         const { stdout } = await execAsync('schtasks /query /tn \"ClaudePing\" /fo list 2>nul');\n         return stdout.includes('TaskName:');\n       }\n     } catch (error) {\n       return false;\n     }\n     \n     return false;\n   }\n   \n   async function setupAutoStart() {\n     const platform = process.platform;\n     const execPath = process.execPath; // Node.js executable\n     const scriptPath = path.resolve(path.join(__dirname, '../..', 'bin/claude-ping.js'));\n     \n     try {\n       if (platform === 'darwin') { // macOS\n         const plistContent = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>Label</key>\n    <string>com.claude-ping</string>\n    <key>ProgramArguments</key>\n    <array>\n        <string>${execPath}</string>\n        <string>${scriptPath}</string>\n        <string>start</string>\n    </array>\n    <key>RunAtLoad</key>\n    <true/>\n    <key>KeepAlive</key>\n    <false/>\n    <key>StandardOutPath</key>\n    <string>${path.join(os.homedir(), '.claude-ping/output.log')}</string>\n    <key>StandardErrorPath</key>\n    <string>${path.join(os.homedir(), '.claude-ping/error.log')}</string>\n</dict>\n</plist>`;\n         \n         fs.ensureDirSync(path.dirname(MACOS_PLIST_PATH));\n         fs.writeFileSync(MACOS_PLIST_PATH, plistContent);\n         await execAsync(`launchctl load -w ${MACOS_PLIST_PATH}`);\n         \n       } else if (platform === 'linux') { // Linux\n         const serviceContent = `[Unit]\nDescription=Claude Ping Service\n\n[Service]\nExecStart=${execPath} ${scriptPath} start\nRestart=on-failure\nRestartSec=10\nEnvironment=PATH=/usr/bin:/usr/local/bin:${process.env.PATH}\n\n[Install]\nWantedBy=default.target`;\n         \n         fs.ensureDirSync(path.dirname(LINUX_SERVICE_PATH));\n         fs.writeFileSync(LINUX_SERVICE_PATH, serviceContent);\n         await execAsync('systemctl --user daemon-reload');\n         await execAsync('systemctl --user enable claude-ping.service');\n         \n       } else if (platform === 'win32') { // Windows\n         const command = `schtasks /create /tn \"ClaudePing\" /sc onlogon /tr \"\\\"${execPath}\\\" \\\"${scriptPath}\\\" start\" /ru \"${os.userInfo().username}\" /f`;\n         await execAsync(command);\n       }\n       \n       return true;\n     } catch (error) {\n       logger.error(`Failed to setup auto-start: ${error.message}`);\n       return false;\n     }\n   }\n   \n   async function removeAutoStart() {\n     const platform = process.platform;\n     \n     try {\n       if (platform === 'darwin') { // macOS\n         if (fs.existsSync(MACOS_PLIST_PATH)) {\n           await execAsync(`launchctl unload -w ${MACOS_PLIST_PATH}`);\n           fs.unlinkSync(MACOS_PLIST_PATH);\n         }\n       } else if (platform === 'linux') { // Linux\n         if (fs.existsSync(LINUX_SERVICE_PATH)) {\n           await execAsync('systemctl --user disable claude-ping.service');\n           fs.unlinkSync(LINUX_SERVICE_PATH);\n           await execAsync('systemctl --user daemon-reload');\n         }\n       } else if (platform === 'win32') { // Windows\n         await execAsync('schtasks /delete /tn \"ClaudePing\" /f');\n       }\n       \n       return true;\n     } catch (error) {\n       logger.error(`Failed to remove auto-start: ${error.message}`);\n       return false;\n     }\n   }\n   \n   module.exports = {\n     checkAutoStartService,\n     setupAutoStart,\n     removeAutoStart\n   };\n   ```\n2. Implement platform detection for macOS, Linux, and Windows\n3. Create service files for each platform:\n   - macOS: launchd plist file\n   - Linux: systemd user service\n   - Windows: Task Scheduler task\n4. Add service registration and removal functions\n5. Implement user prompting for service setup",
        "testStrategy": "1. Test platform detection logic\n2. Verify service file creation for each platform\n3. Test service registration and removal\n4. Validate auto-start functionality on system boot\n5. Test user prompting for service setup",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Logging System",
        "description": "Create a logging system for tracking application events and errors",
        "details": "1. Create lib/utils/logger.js:\n   ```javascript\n   const fs = require('fs-extra');\n   const path = require('path');\n   const { CONFIG_DIR } = require('./config-manager');\n   const chalk = require('chalk');\n   \n   // Ensure log directory exists\n   fs.ensureDirSync(CONFIG_DIR);\n   \n   const LOG_FILE = path.join(CONFIG_DIR, 'output.log');\n   const ERROR_LOG_FILE = path.join(CONFIG_DIR, 'error.log');\n   \n   // Log levels\n   const LOG_LEVELS = {\n     debug: 0,\n     info: 1,\n     warn: 2,\n     error: 3\n   };\n   \n   let currentLogLevel = 'info';\n   \n   function setLogLevel(level) {\n     if (LOG_LEVELS[level] !== undefined) {\n       currentLogLevel = level;\n     }\n   }\n   \n   function shouldLog(level) {\n     return LOG_LEVELS[level] >= LOG_LEVELS[currentLogLevel];\n   }\n   \n   function formatMessage(message) {\n     const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);\n     return `[${timestamp}] ${message}`;\n   }\n   \n   function appendToLog(message, isError = false) {\n     const formattedMessage = formatMessage(message);\n     const file = isError ? ERROR_LOG_FILE : LOG_FILE;\n     \n     try {\n       fs.appendFileSync(file, formattedMessage + '\\n');\n     } catch (error) {\n       console.error(`Failed to write to log file: ${error.message}`);\n     }\n   }\n   \n   function debug(message) {\n     if (!shouldLog('debug')) return;\n     \n     console.log(chalk.gray(formatMessage(message)));\n     appendToLog(`[DEBUG] ${message}`);\n   }\n   \n   function info(message) {\n     if (!shouldLog('info')) return;\n     \n     console.log(formatMessage(message));\n     appendToLog(`[INFO] ${message}`);\n   }\n   \n   function warn(message) {\n     if (!shouldLog('warn')) return;\n     \n     console.log(chalk.yellow(formatMessage(message)));\n     appendToLog(`[WARN] ${message}`);\n   }\n   \n   function error(message, err) {\n     if (!shouldLog('error')) return;\n     \n     const errorMessage = err ? `${message}: ${err.message}` : message;\n     console.error(chalk.red(formatMessage(errorMessage)));\n     appendToLog(`[ERROR] ${errorMessage}`, true);\n     \n     if (err && err.stack) {\n       appendToLog(`[ERROR] ${err.stack}`, true);\n     }\n   }\n   \n   function getRecentLogs(count = 5) {\n     try {\n       if (fs.existsSync(LOG_FILE)) {\n         const logs = fs.readFileSync(LOG_FILE, 'utf8')\n           .split('\\n')\n           .filter(line => line.trim())\n           .slice(-count);\n         return logs;\n       }\n     } catch (error) {\n       console.error(`Failed to read log file: ${error.message}`);\n     }\n     return [];\n   }\n   \n   module.exports = {\n     debug,\n     info,\n     warn,\n     error,\n     setLogLevel,\n     getRecentLogs,\n     LOG_FILE,\n     ERROR_LOG_FILE\n   };\n   ```\n2. Implement log rotation to prevent excessive file growth\n3. Add colored console output for different log levels\n4. Create log file structure with timestamps\n5. Implement log level filtering based on configuration",
        "testStrategy": "1. Test log file creation and writing\n2. Verify log level filtering\n3. Test log rotation functionality\n4. Validate error logging with stack traces\n5. Test recent logs retrieval for status command",
        "priority": "medium",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Status and Test Commands",
        "description": "Create status and test commands for monitoring and troubleshooting",
        "details": "1. Implement lib/commands/status.js:\n   ```javascript\n   const { getPid, isRunning } = require('../services/process-manager');\n   const { getConfig } = require('../utils/config-manager');\n   const logger = require('../utils/logger');\n   const fs = require('fs-extra');\n   const path = require('path');\n   const chalk = require('chalk');\n   \n   module.exports = function() {\n     const pid = getPid();\n     const isProcessRunning = pid && isRunning(pid);\n     const config = getConfig();\n     \n     if (isProcessRunning) {\n       console.log(chalk.green(`✅ Claude Ping is running (PID: ${pid})`));\n       \n       // Calculate next ping time\n       try {\n         const logFile = logger.LOG_FILE;\n         if (fs.existsSync(logFile)) {\n           const logs = fs.readFileSync(logFile, 'utf8').split('\\n');\n           \n           // Find last ping time\n           const lastPingLog = logs.reverse().find(line => \n             line.includes('timer triggered') || \n             line.includes('Starting Claude session')\n           );\n           \n           if (lastPingLog) {\n             const match = lastPingLog.match(/\\[(.*?)\\]/);\n             if (match && match[1]) {\n               const lastPingTime = new Date(match[1]);\n               const nextPingTime = new Date(lastPingTime.getTime() + config.intervalHours * 60 * 60 * 1000);\n               const now = new Date();\n               \n               const timeUntilNextPing = nextPingTime - now;\n               if (timeUntilNextPing > 0) {\n                 const hours = Math.floor(timeUntilNextPing / (60 * 60 * 1000));\n                 const minutes = Math.floor((timeUntilNextPing % (60 * 60 * 1000)) / (60 * 1000));\n                 console.log(chalk.blue(`📅 Next ping: in ${hours}h ${minutes}m`));\n               } else {\n                 console.log(chalk.blue(`📅 Next ping: imminent`));\n               }\n               \n               console.log(chalk.blue(`⏰ Last ping: ${lastPingTime.toLocaleString()}`));\n             }\n           }\n           \n           // Find last retry sequence completion\n           const lastRetryLog = logs.find(line => line.includes('Retry sequence complete'));\n           if (lastRetryLog) {\n             const match = lastRetryLog.match(/\\[(.*?)\\]/);\n             if (match && match[1]) {\n               const successMatch = lastRetryLog.match(/(\\d+)\\/(\\d+) attempts succeeded/);\n               if (successMatch) {\n                 console.log(chalk.blue(`🔄 Last sequence: ${successMatch[1]}/${successMatch[2]} attempts completed`));\n               }\n             }\n           }\n           \n           // Show recent activity\n           const recentLogs = logger.getRecentLogs(5);\n           if (recentLogs.length > 0) {\n             console.log('\\nRecent activity:');\n             recentLogs.forEach(log => {\n               console.log(`  ${log}`);\n             });\n           }\n         }\n       } catch (error) {\n         logger.error('Error reading log file', error);\n       }\n     } else {\n       console.log(chalk.red('❌ Claude Ping is not running'));\n       if (pid) {\n         console.log(chalk.yellow(`⚠️ Stale PID file found: ${pid}`));\n       }\n     }\n     \n     // Show configuration summary\n     console.log('\\nConfiguration:');\n     console.log(`  Interval: ${config.intervalHours} hours`);\n     console.log(`  Retry count: ${config.retryCount}`);\n     console.log(`  Retry interval: ${config.retryInterval} minutes`);\n   };\n   ```\n\n2. Implement lib/commands/test.js:\n   ```javascript\n   const { pingClaude, checkClaudeInstallation } = require('../services/claude-service');\n   const logger = require('../utils/logger');\n   const chalk = require('chalk');\n   \n   module.exports = async function() {\n     console.log(chalk.blue('🔍 Testing Claude connection...'));\n     \n     try {\n       // Check if Claude is installed\n       const isInstalled = await checkClaudeInstallation();\n       if (!isInstalled) {\n         console.log(chalk.red('❌ Claude CLI is not installed or not in PATH'));\n         console.log(chalk.yellow('Please install Claude CLI:'));\n         console.log('  npm install -g @anthropic-ai/claude-code');\n         console.log('  claude auth');\n         return;\n       }\n       \n       console.log(chalk.green('✅ Claude CLI is installed'));\n       \n       // Test Claude connection\n       console.log(chalk.blue('🔄 Sending test message to Claude...'));\n       await pingClaude();\n       console.log(chalk.green('✅ Claude connection successful!'));\n     } catch (error) {\n       console.log(chalk.red(`❌ Test failed: ${error.message}`));\n       \n       if (error.message.includes('auth')) {\n         console.log(chalk.yellow('\\nAuthentication issue detected. Try running:'));\n         console.log('  claude auth');\n       } else {\n         console.log(chalk.yellow('\\nTroubleshooting steps:'));\n         console.log('1. Check your internet connection');\n         console.log('2. Verify Claude CLI is properly installed');\n         console.log('3. Run \"claude auth\" to refresh authentication');\n         console.log('4. Try running Claude manually to check for issues');\n       }\n     }\n   };\n   ```\n\n3. Implement lib/commands/config.js:\n   ```javascript\n   const { getConfig, CONFIG_FILE } = require('../utils/config-manager');\n   const chalk = require('chalk');\n   \n   module.exports = function() {\n     const config = getConfig();\n     \n     console.log(chalk.blue(`Configuration file: ${CONFIG_FILE}`));\n     console.log(JSON.stringify(config, null, 2));\n     console.log('\\nTo modify settings, edit this file or use command options.');\n   };\n   ```\n\n4. Implement lib/commands/stop.js:\n   ```javascript\n   const { getPid, isRunning, removePid } = require('../services/process-manager');\n   const logger = require('../utils/logger');\n   const chalk = require('chalk');\n   \n   module.exports = function() {\n     const pid = getPid();\n     \n     if (!pid) {\n       console.log(chalk.yellow('⚠️ No running process found'));\n       return;\n     }\n     \n     if (isRunning(pid)) {\n       console.log(chalk.blue(`🛑 Stopping Claude Ping (PID: ${pid})...`));\n       \n       try {\n         process.kill(pid, 'SIGTERM');\n         console.log(chalk.green('✅ Process stopped successfully'));\n       } catch (error) {\n         console.log(chalk.red(`❌ Failed to stop process: ${error.message}`));\n         console.log(chalk.yellow('Removing stale PID file...'));\n         removePid();\n       }\n     } else {\n       console.log(chalk.yellow(`⚠️ Process with PID ${pid} is not running`));\n       console.log(chalk.blue('Removing stale PID file...'));\n       removePid();\n     }\n   };\n   ```\n\n5. Add detailed status information including next ping time and recent activity",
        "testStrategy": "1. Test status command output for running process\n2. Test status command output for stopped process\n3. Verify test command correctly checks Claude installation\n4. Test config command output format\n5. Verify stop command correctly terminates process\n6. Test error handling in all commands",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create Documentation and Package for Distribution",
        "description": "Prepare the package for distribution with documentation, README, and npm configuration",
        "details": "1. Create comprehensive README.md:\n   ```markdown\n   # Claude Ping\n   \n   A Node.js CLI tool that automatically pings Claude Code CLI every 5 hours to reset tokens.\n   \n   ## Features\n   \n   - **Token Optimization**: Automatically resets tokens every 5 hours\n   - **Unattended Operation**: Runs in the background, starts on boot\n   - **Easy to Use**: Simple installation and setup\n   - **No Admin Rights**: Runs without sudo/administrator privileges\n   \n   ## Prerequisites\n   \n   1. **Node.js 18.0.0 or higher**\n   2. **Claude Code CLI installed and authenticated**\n      ```bash\n      npm install -g @anthropic-ai/claude-code\n      claude auth\n      ```\n   \n   ## Installation\n   \n   ```bash\n   npm install -g claude-ping\n   ```\n   \n   ## Usage\n   \n   ### Starting the Service\n   \n   ```bash\n   # Start with default settings (5-hour interval)\n   claude-ping start\n   \n   # Start with custom interval (3 hours)\n   claude-ping start -i 3\n   \n   # Start in foreground mode to see logs\n   claude-ping start --foreground\n   ```\n   \n   ### Checking Status\n   \n   ```bash\n   claude-ping status\n   ```\n   \n   ### Testing Connection\n   \n   ```bash\n   claude-ping test\n   ```\n   \n   ### Viewing Configuration\n   \n   ```bash\n   claude-ping config\n   ```\n   \n   ### Stopping the Service\n   \n   ```bash\n   claude-ping stop\n   ```\n   \n   ## Command Options\n   \n   ### Start Command\n   \n   - `-i, --interval <hours>`: Set ping interval in hours (1-24, default: 5)\n   - `-f, --foreground`: Run in foreground mode with visible logs\n   - `--retry-count <count>`: Number of consecutive retries (1-10, default: 3)\n   - `--retry-interval <minutes>`: Minutes between retries (1-10, default: 2)\n   - `--no-retry`: Disable retry mechanism (run once per interval)\n   \n   ## Configuration\n   \n   Configuration is stored in `~/.claude-ping/config.json` and can be modified directly:\n   \n   ```json\n   {\n     \"intervalHours\": 5,\n     \"timeout\": 30000,\n     \"retryCount\": 3,\n     \"retryInterval\": 2,\n     \"question\": \"What time is it now?\",\n     \"logLevel\": \"info\",\n     \"autoRestart\": true\n   }\n   ```\n   \n   ## Troubleshooting\n   \n   ### Logs\n   \n   Logs are stored in:\n   - `~/.claude-ping/output.log`\n   - `~/.claude-ping/error.log`\n   \n   ### Common Issues\n   \n   **Claude CLI not found**\n   \n   Ensure Claude CLI is installed and in your PATH:\n   ```bash\n   npm install -g @anthropic-ai/claude-code\n   ```\n   \n   **Authentication Issues**\n   \n   Re-authenticate with Claude:\n   ```bash\n   claude auth\n   ```\n   \n   **Process Not Starting**\n   \n   Check for errors:\n   ```bash\n   cat ~/.claude-ping/error.log\n   ```\n   \n   ## License\n   \n   MIT\n   ```\n\n2. Configure package.json for global installation:\n   ```json\n   {\n     \"name\": \"claude-ping\",\n     \"version\": \"1.0.0\",\n     \"description\": \"Claude Code CLI token optimization automation tool\",\n     \"main\": \"lib/index.js\",\n     \"bin\": {\n       \"claude-ping\": \"./bin/claude-ping.js\"\n     },\n     \"scripts\": {\n       \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n     },\n     \"keywords\": [\n       \"claude\",\n       \"anthropic\",\n       \"cli\",\n       \"token\",\n       \"automation\"\n     ],\n     \"author\": \"\",\n     \"license\": \"MIT\",\n     \"dependencies\": {\n       \"chalk\": \"^4.1.2\",\n       \"commander\": \"^9.4.1\",\n       \"fs-extra\": \"^10.1.0\",\n       \"inquirer\": \"^8.2.5\"\n     },\n     \"engines\": {\n       \"node\": \">=18.0.0\"\n     }\n   }\n   ```\n\n3. Create .npmignore file to exclude unnecessary files from the package\n4. Add license file (MIT)\n5. Create example configuration files for different use cases",
        "testStrategy": "1. Test npm installation process\n2. Verify global command registration\n3. Test README instructions for accuracy\n4. Validate package.json configuration\n5. Test installation on different platforms (macOS, Linux, Windows)",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-01T10:42:50.920Z",
      "updated": "2025-07-01T10:42:50.920Z",
      "description": "Tasks for master context"
    }
  }
}